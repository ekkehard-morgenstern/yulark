
YULARK built-in language
------------------------

Sprachdefinition:

    Wie kann man die Sprache am besten definieren?

    Kann man FORTH's "Compiles / DOES>" Syntax irgendwie nutzen?

    In FORTH definiert

        : CONSTANT CREATE , DOES> @ ;

    den Dictionary-Eintrag CONSTANT und compiliert mit "," das auf dem
    Stack liegende (numerische) Wort in das Parameterfeld, sodass

        76 CONSTANT BLA

    eine Konstante "BLA" anlegt mit dem Wert 76 im Parameterfeld.
    Beim Aufruf von BLA wird mit "@" die Adresse des Parameterfelds
    vom Stack geholt (das der Compiler fuer den Aufruf dorthin gelegt hat)
    und dann diese Adresse ausgelesen (der Wert / das Wort 76) und dann
    auf den Stack gelegt, sodass

        BLA .

    den Wert 76 ausgibt.

    Wie muesste ein FORTH-System aussehen, dass die Sprache von YULARK
    compilieren kann? Und wie muesste YULARK's Laufzeitsystem dann
    aussehen?

    Eine dynamische Keywordmap, die bereits definierte Worte enthaelt,
    waere auf jeden Fall besser als eine statische.

    Die Frage ist dann auch wie man das System bauen kann, sodass beim
    Start nicht erst das System selbst compiliert werden muss. Das muss
    also bereits beim Bauen geschehen.

    YULARK muss also eine Art FORTH-Laufzeitsystem enthalten, das bereits
    vorkompiliert wurde. Wenn dann ein Sourcefile durchlaufen wird, wird
    der Source dann als Programm ausgefuehrt (was dann wiederum Code
    generieren koennte, der dann gecached werden kann bspw).

    Dieser Ansatz koennte praktikabler sein als mein klassischer Versuch,
    bspw. eine vorkompilerte EBNF zu verwenden.

Minimales FORTH-System

    Register:
        PSP     - parameter stack pointer
        RSP     - return stack pointer
        WP      - word pointer
        WA      - word address

    Wortdefinitionen (Dictionary-Eintraege)

        +--------------------+
        |  link to previous  |
        +-----+--------------+
        | NLF | NAME ...     |
        +--------------------+
        | NAME ... PAD 0 0 0 | (optional, remainder of name and pad bytes)
        +--------------------+
        |  code-addr / DOCOL |
        +--------------------+
        |  definition ...    | word-addresses
        +--------------------+

    NEXT:
        Beschliesst jedes FORTH Wort (wenn es in Maschinencode geschrieben ist)
        WA := [WP]+
        JUMP [WA]

    DOCOL:
        Startet die Verarbeitung eines FORTH-Worts
        -[RSP] := WP
        WP := +WA     ; +1 word
        NEXT

    EXIT:
        Beendet die Verarbeitung eines FORTH-Worts (letzte Adresse)
        WP := [RSP]+
        NEXT

Spielfeld:

label: bla = 1
label  bla = 1

FOO   CALL bla.spurt 10+5,20,30
      bla.spurt 99,999
      LET xy = 2.4 * 43 + yank(7)

FUNCTION yank(a)
RESULT a * 29
END

CLASS raspberry
    PROPERTY taste
    FUNCTION getTaste
        RESULT [this.]taste
    END
    COMMAND setTaste xy
        taste = xy
    END
END

Free-form Definition:

Kommando:
    [line-number-or-label] [CALL] [<ref-list>.]<cmd-name> [[name:]arg{, [name:]arg}]

Zuweisung:
    [line-number-or-label] [LET] <assign-expr>{, <assign-expr>} = <expr>{, <expr>}

Ausdrücke:
    (das Übliche)

Kommandodeklaration (prozedural oder OOP):
    COMMAND [ref-list.]<cmd-name> [<arg-name>[=default]{, <arg-name>[=default]}]
    ...
    END [COMMAND]

Funktionsdeklaration (prozedural oder OOP):
    FUNCTION [ref-list.]<fn-name> ( <arg-name>[=<default>]{, <arg-name>[=<default>]} )

        RESULT <expr>{, <expr>}
    END [FUNCTION]

Klassendeklaration:
    (Methoden können innerhalb oder außerhalb von Klassendefinitionen definiert werden)

    CLASS [ref-list.]<cls-name> [EXTENDS [ref-list.]<cls-name>{, [ref-list.]<cls-name>}] [IMPLEMENTS [ref-list.]<ifc-name>{, [ref-list.]<ifc-name>}]

        PROPERTY <name>{, <name>}

        ... unqualifizierte Kommandos und Funktionen ...

        Konstruktor: Kommando INIT
        Destruktor: Kommando DESTROY

    END [CLASS]

Objekt-allokierung:

    Ausdruck    A = NEW B [<konstruktor-parameter-liste>]

    Default-Setter/Getter

Objekt-deallokierung

    Kommando    DELETE A (Objekt-Liste)

Array-allokierung:

    Ausdruck    A = ARRAY (Dimensions-Liste)

    Dimension DYNAMIC erzeugt dynamisches Array (nur 1-dimensionales Array)
    Dimension ASSOC erzeugt assoziatives Array (nur 1-dimensionales Array)

Array-Verwendung:

    B = ARRAY 20,30
    B[10,20] = 5
    A = B[10,20]

    B = ARRAY DYNAMIC
    B[150] = C

    C = ARRAY ASSOC
    C["FOO"] = "BAR"
    C[15] = "YO"
    C["BAR"] = 39

Array-Deallokierung wie Objekt-Deallokierung

Verbatim-Sektionen

VERBATIM
    ... wird nach Ausgabe kopiert ...
    ... Referenzen der Form {{var}} werden expandiert ...
END [VERBATIM]

Includes

INCLUDE <file-name>

Defines / constants
[DEFINE|CONST|ENUM] <name> [ = <expr> ] { , <name> [ = <expr> ] }

    ENUM expressions are automatically incremented left to right, if no
    expression is given.
    With CONST, expressions are required.
    With DEFINE, expressions are optional.

Imports

IMPORT <identifier-list> [ FROM <file-name> ]

Exports

EXPORT <identifier-list>

Conditionals

IFDEF / IFNDEF <name>
IF <condition>
    ...
ELSE
    ...
ENDIF

Loops

FOR <key-name>[,<val-name>] IN <array>
FOR <name> = <expr> TO|DOWNTO <expr> [STEP <expr>]
FOR EVER | FOREVER
    ...
    CONTINUE
    BREAK
    AGAIN
    ...
END [FOR]

REPEAT
    ...
UNTIL <expr>

WHILE <expr>
    ...
WEND

GOTO <label-or-line-number>

GOSUB <label-or-line-number>
    ...
RETURN

SWITCH <expr>
    ...
    CASE <expr>
        ...
    END [CASE]
    ...
    DEFAULT
        ...
    END [DEFAULT]
    ...
END [SWITCH]

Built-in functions:

    result = HTTP( protocol, method, url )

    result = TO_JSON( <expr> )
    result = FROM_JSON( <expr> )

    result = INSERT( <insert-args> )

Database:

    DATABASE <internal-name>, <protocol>, <url>, <instance>, <credentials>

        SELECT <select-stmt>

        UPDATE <update-stmt>

        DELETE <delete-stmt>

    END [DATABASE]

Status / error handling:

STATUS [HTTP] <expr>
    ...
END [STATUS]

Formale Definition:

Expression-EBNF:

identifier := /[A-Za-z0-9_]+/ .
dec-n := /[0-9]+(\.[0-9]+)([eE][+-]?[0-9]+)?/ .
oct-n := /@[0-7]+(\.[0-7]+)([eE][+-]?[0-7]+)?/ .
bin-n := /\%[0-1]+(\.[0-1]+)([eE][+-]?[0-1]+)?/ .
hex-n := /\$[0-9A-Fa-f]+(\.[0-9A-Fa-f]+)('[+-]?[0-9]+)?/ .

number := hex-n | bin-n | oct-n | dec-n .


ctrl-chr-esc := /[abetrn]/ .
hex-chr-esc := /x[0-9a-fA-F]{1,2}/ .
oct-chr-esc := /[0-7]{1,3}/ .
bin-chr-esc := /b[0-1]{1,8}/ .
sng-chr-esc := '\\' | '"' | "'" .
chr-esc := ctrl-chr-esc | hex-chr-esc | oct-chr-esc | bin-chr-esc |
           sng-chr-esc  .

str-esc := "\\" chr-esc .
str-chr1 := /[^"\\]/ | str-esc .
str-chr2 := /[^'\\]/ | str-esc .
str-seq1 := '"' { str-chr1 } '"' .
str-seq2 := "'" { str-chr2 } "'" .
string := str-seq1 | str-seq2 .

str-or-num := string | number .

range-expr := expr [ '..' expr ] .

fn-ap-arg := [ identifier '=' ] range-expr .
fn-ap-arg-list := fn-ap-arg { ',' fn-ap-arg } .
fn-ap := '(' [ fn-ap-arg-list ] ')' .

array-ap-arg := range-expr .
array-ap-arg-list := array-ap-arg { ',' array-ap-arg } .
array-ap := '[' [ array-ap-arg-list ] ']' .

fn-or-array-ap := fn-ap | array-ap .

sub-expr := '(' expr ')' .

ref := identifier .
root-ref := '::' .
ref-list := [ root-ref ] identifier '.' { identifier '.' } .

base-expr := [ ref-list ] identifier [ fn-or-array-ap ] | str-or-num
           | sub-expr .

unary-op := '-' | 'NOT' | 'ADDROF' .
unary-expr := [ unary-op ] base-expr .

mult-op := '*' | '**' | '/' | 'MOD' .
mult-expr := unary-expr { mult-op unary-expr } .

add-op := '+' | '-' .
add-expr := mult-op { add-op mult-op } .

shf-op := 'LSH' | 'RSH' .
shf-expr := add-expr [ shf-op add-expr ] .

cmp-op := '=' | '<>' | '<=' | '>=' | '<' | '>' .
cmp-expr := shf-expr [ cmp-op shf-expr ] .

and-op := 'AND' | 'NAND' .
and-expr := cmp-expr { and-op cmp-expr } .

or-op := 'OR' | 'NOR' | 'XOR' | 'XNOR' .
or-expr := and-expr { or-op and-expr } .

expr := or-expr .
