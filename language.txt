
YULARK built-in language
------------------------

Spielfeld:

label: bla = 1
label  bla = 1

FOO   CALL bla.spurt 10+5,20,30
      bla.spurt 99,999
      LET xy = 2.4 * 43 + yank(7)

FUNCTION yank(a)
RESULT a * 29
END

CLASS raspberry
    PROPERTY taste
    FUNCTION getTaste
        RESULT [this.]taste
    END
    COMMAND setTaste xy
        taste = xy
    END
END

Free-form Definition:

Kommando:
    [line-number-or-label] [CALL] [<ref-list>.]<cmd-name> [[name:]arg{, [name:]arg}]

Zuweisung:
    [line-number-or-label] [LET] <assign-expr>{, <assign-expr>} = <expr>{, <expr>}

Ausdrücke:
    (das Übliche)

Kommandodeklaration (prozedural oder OOP):
    COMMAND [ref-list.]<cmd-name> [<arg-name>[=default]{, <arg-name>[=default]}]
    ...
    END [COMMAND]

Funktionsdeklaration (prozedural oder OOP):
    FUNCTION [ref-list.]<fn-name> ( <arg-name>[=<default>]{, <arg-name>[=<default>]} )

        RESULT <expr>{, <expr>}
    END [FUNCTION]

Klassendeklaration:
    (Methoden können innerhalb oder außerhalb von Klassendefinitionen definiert werden)

    CLASS [ref-list.]<cls-name> [EXTENDS [ref-list.]<cls-name>{, [ref-list.]<cls-name>}] [IMPLEMENTS [ref-list.]<ifc-name>{, [ref-list.]<ifc-name>}]

        PROPERTY <name>{, <name>}

        ... unqualifizierte Kommandos und Funktionen ...

        Konstruktor: Kommando INIT
        Destruktor: Kommando DESTROY

    END [CLASS]

Objekt-allokierung:

    Ausdruck    A = NEW B

    Default-Setter/Getter


Formale Definition:
