
YULARK built-in language
------------------------

Spielfeld:

label: bla = 1
label  bla = 1

FOO   CALL bla.spurt 10+5,20,30
      bla.spurt 99,999
      LET xy = 2.4 * 43 + yank(7)

FUNCTION yank(a)
RESULT a * 29
END

CLASS raspberry
    PROPERTY taste
    FUNCTION getTaste
        RESULT [this.]taste
    END
    COMMAND setTaste xy
        taste = xy
    END
END

Free-form Definition:

Kommando:
    [line-number-or-label] [CALL] [<ref-list>.]<cmd-name> [[name:]arg{, [name:]arg}]

Zuweisung:
    [line-number-or-label] [LET] <assign-expr>{, <assign-expr>} = <expr>{, <expr>}

Ausdrücke:
    (das Übliche)

Kommandodeklaration (prozedural oder OOP):
    COMMAND [ref-list.]<cmd-name> [<arg-name>[=default]{, <arg-name>[=default]}]
    ...
    END [COMMAND]

Funktionsdeklaration (prozedural oder OOP):
    FUNCTION [ref-list.]<fn-name> ( <arg-name>[=<default>]{, <arg-name>[=<default>]} )

        RESULT <expr>{, <expr>}
    END [FUNCTION]

Klassendeklaration:
    (Methoden können innerhalb oder außerhalb von Klassendefinitionen definiert werden)

    CLASS [ref-list.]<cls-name> [EXTENDS [ref-list.]<cls-name>{, [ref-list.]<cls-name>}] [IMPLEMENTS [ref-list.]<ifc-name>{, [ref-list.]<ifc-name>}]

        PROPERTY <name>{, <name>}

        ... unqualifizierte Kommandos und Funktionen ...

        Konstruktor: Kommando INIT
        Destruktor: Kommando DESTROY

    END [CLASS]

Objekt-allokierung:

    Ausdruck    A = NEW B [<konstruktor-parameter-liste>]

    Default-Setter/Getter

Objekt-deallokierung

    Kommando    DELETE A (Objekt-Liste)

Array-allokierung:

    Ausdruck    A = ARRAY (Dimensions-Liste)

    Dimension DYNAMIC erzeugt dynamisches Array (nur 1-dimensionales Array)
    Dimension ASSOC erzeugt assoziatives Array (nur 1-dimensionales Array)

Array-Verwendung:

    B = ARRAY 20,30
    B[10,20] = 5
    A = B[10,20]

    B = ARRAY DYNAMIC
    B[150] = C

    C = ARRAY ASSOC
    C["FOO"] = "BAR"
    C[15] = "YO"
    C["BAR"] = 39

Array-Deallokierung wie Objekt-Deallokierung

Verbatim-Sektionen

VERBATIM
    ... wird nach Ausgabe kopiert ...
    ... Referenzen der Form {{var}} werden expandiert ...
END [VERBATIM]

Includes

INCLUDE <file-name>

Conditionals

IFDEF / IFNDEF <name>
IF <condition>
    ...
ELSE
    ...
ENDIF

Loops

FOR <key-name>[,<val-name>] IN <array>
FOR <name> = <expr> TO|DOWNTO <expr> [STEP <expr>]
    ...
    CONTINUE
    BREAK
    AGAIN
    ...
END [FOR]



Formale Definition:
